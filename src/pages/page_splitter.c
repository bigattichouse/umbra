/**
 * @file page_splitter.c
 * @brief Handles page splitting when full
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <errno.h>
#include "page_splitter.h"
#include "page_generator.h"
#include "../schema/directory_manager.h"

/**
 * @brief Check if a page needs to be split
 */
int check_page_split(const TableSchema* schema, const char* base_dir, 
                    int page_number, int max_records, bool* needs_split) {
    if (!schema || !base_dir || !needs_split) {
        return -1;
    }
    
    bool is_full;
    if (is_page_full(schema, base_dir, page_number, max_records, &is_full) != 0) {
        return -1;
    }
    
    *needs_split = is_full;
    return 0;
}

/**
 * @brief Read records from a data page file
 */
static int read_page_records(const char* data_path, char*** records_out, int* record_count_out) {
    if (!data_path || !records_out || !record_count_out) {
        return -1;
    }
    
    FILE* file = fopen(data_path, "r");
    if (!file) {
        fprintf(stderr, "Failed to open %s for reading: %s\n", data_path, strerror(errno));
        return -1;
    }
    
    // Count records and read them
    int count = 0;
    char line[4096];
    char** records = NULL;
    
    while (fgets(line, sizeof(line), file)) {
        // Check if line contains a record (ends with "},\n")
        size_t len = strlen(line);
        if (len >= 3 && line[len-3] == '}' && line[len-2] == ',' && line[len-1] == '\n') {
            // Allocate more space for records array
            char** new_records = realloc(records, (count + 1) * sizeof(char*));
            if (!new_records) {
                fprintf(stderr, "Memory allocation failed\n");
                fclose(file);
                
                // Free allocated records
                for (int i = 0; i < count; i++) {
                    free(records[i]);
                }
                free(records);
                
                return -1;
            }
            
            records = new_records;
            
            // Allocate space for the record and copy it
            records[count] = strdup(line);
            if (!records[count]) {
                fprintf(stderr, "Memory allocation failed\n");
                fclose(file);
                
                // Free allocated records
                for (int i = 0; i < count; i++) {
                    free(records[i]);
                }
                free(records);
                
                return -1;
            }
            
            count++;
        }
    }
    
    fclose(file);
    
    *records_out = records;
    *record_count_out = count;
    return 0;
}

/**
 * @brief Write records to a data page file
 */
static int write_page_records(const char* data_path, char** records, int record_count) {
    if (!data_path || (!records && record_count > 0)) {
        return -1;
    }
    
    FILE* file = fopen(data_path, "w");
    if (!file) {
        fprintf(stderr, "Failed to open %s for writing: %s\n", data_path, strerror(errno));
        return -1;
    }
    
    // Write header comment
    fprintf(file, "/*This file autogenerated, do not edit manually*/\n");
    
    // Write each record
    for (int i = 0; i < record_count; i++) {
        fprintf(file, "%s", records[i]);
    }
    
    fclose(file);
    return 0;
}

/**
 * @brief Split a full page into two pages
 */
int split_page(const TableSchema* schema, const char* base_dir, 
              int full_page_number, int new_page_number, 
              int max_records, int split_point) {
    if (!schema || !base_dir || split_point <= 0 || split_point >= max_records) {
        return -1;
    }
    
    // Get data directory path
    char data_dir[1024];
    if (get_data_directory(schema->name, base_dir, data_dir, sizeof(data_dir)) != 0) {
        return -1;
    }
    
    // Get full page data path
    char full_page_path[1024];
    snprintf(full_page_path, sizeof(full_page_path), "%s/%sData.%d.dat.h", 
             data_dir, schema->name, full_page_number);
    
    // Read records from full page
    char** records;
    int record_count;
    if (read_page_records(full_page_path, &records, &record_count) != 0) {
        return -1;
    }
    
    // Ensure split point is valid
    if (split_point >= record_count) {
        fprintf(stderr, "Invalid split point: %d (record count: %d)\n", split_point, record_count);
        
        // Free allocated records
        for (int i = 0; i < record_count; i++) {
            free(records[i]);
        }
        free(records);
        
        return -1;
    }
    
    // Generate new page
    if (generate_data_page(schema, base_dir, new_page_number) != 0) {
        // Free allocated records
        for (int i = 0; i < record_count; i++) {
            free(records[i]);
        }
        free(records);
        
        return -1;
    }
    
    // Get new page data path
    char new_page_path[1024];
    snprintf(new_page_path, sizeof(new_page_path), "%s/%sData.%d.dat.h", 
             data_dir, schema->name, new_page_number);
    
    // Write first part to original page
    if (write_page_records(full_page_path, records, split_point) != 0) {
        // Free allocated records
        for (int i = 0; i < record_count; i++) {
            free(records[i]);
        }
        free(records);
        
        return -1;
    }
    
    // Write second part to new page
    if (write_page_records(new_page_path, records + split_point, record_count - split_point) != 0) {
        // Free allocated records
        for (int i = 0; i < record_count; i++) {
            free(records[i]);
        }
        free(records);
        
        return -1;
    }
    
    // Recompile both pages
    if (recompile_data_page(schema, base_dir, full_page_number) != 0 ||
        recompile_data_page(schema, base_dir, new_page_number) != 0) {
        // Free allocated records
        for (int i = 0; i < record_count; i++) {
            free(records[i]);
        }
        free(records);
        
        return -1;
    }
    
    // Free allocated records
    for (int i = 0; i < record_count; i++) {
        free(records[i]);
    }
    free(records);
    
    return 0;
}

/**
 * @brief Get the number of pages in a table
 */
static int count_table_pages(const TableSchema* schema, const char* base_dir) {
    if (!schema || !base_dir) {
        return -1;
    }
    
    // Get data directory path
    char data_dir[1024];
    if (get_data_directory(schema->name, base_dir, data_dir, sizeof(data_dir)) != 0) {
        return -1;
    }
    
    // Open directory
    DIR* dir = opendir(data_dir);
    if (!dir) {
        fprintf(stderr, "Failed to open directory %s: %s\n", data_dir, strerror(errno));
        return -1;
    }
    
    // Count data page files
    int count = 0;
    struct dirent* entry;
    
    while ((entry = readdir(dir)) != NULL) {
        // Check if filename matches pattern: {table}Data.{number}.dat.h
        char prefix[256];
        snprintf(prefix, sizeof(prefix), "%sData.", schema->name);
        
        if (strncmp(entry->d_name, prefix, strlen(prefix)) == 0 &&
            strstr(entry->d_name, ".dat.h") != NULL) {
            count++;
        }
    }
    
    closedir(dir);
    return count;
}

/**
 * @brief Get metadata about pages in a table
 */
int get_table_page_info(const TableSchema* schema, const char* base_dir, 
                       int* page_count, int* record_count) {
    if (!schema || !base_dir || !page_count || !record_count) {
        return -1;
    }
    
    // Count pages
    int count = count_table_pages(schema, base_dir);
    if (count < 0) {
        return -1;
    }
    
    *page_count = count;
    *record_count = 0;
    
    // Sum records in all pages
    for (int i = 0; i < count; i++) {
        int page_records;
        if (get_page_record_count(schema, base_dir, i, &page_records) != 0) {
            return -1;
        }
        
        *record_count += page_records;
    }
    
    return 0;
}

/**
 * @brief Find the best page for a new record
 */
int find_best_page_for_insert(const TableSchema* schema, const char* base_dir, 
                             int max_records, int* best_page) {
    if (!schema || !base_dir || max_records <= 0 || !best_page) {
        return -1;
    }
    
    // Get page count
    int page_count;
    int total_records;
    if (get_table_page_info(schema, base_dir, &page_count, &total_records) != 0) {
        return -1;
    }
    
    // If no pages, create first page
    if (page_count == 0) {
        if (generate_data_page(schema, base_dir, 0) != 0) {
            return -1;
        }
        
        *best_page = 0;
        return 0;
    }
    
    // Try to find a non-full page
    for (int i = 0; i < page_count; i++) {
        bool is_full;
        if (is_page_full(schema, base_dir, i, max_records, &is_full) != 0) {
            return -1;
        }
        
        if (!is_full) {
            *best_page = i;
            return 0;
        }
    }
    
    // All pages are full, create a new page
    int new_page = page_count;
    if (generate_data_page(schema, base_dir, new_page) != 0) {
        return -1;
    }
    
    *best_page = new_page;
    return 0;
}
