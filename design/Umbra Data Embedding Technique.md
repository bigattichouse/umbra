# Umbra Data Embedding Technique

## Core Technical Approach

The Umbra database system employs a novel approach to data storage and loading that fundamentally differs from traditional database systems. Rather than storing data in separate binary files that must be parsed at runtime, Umbra embeds data directly into C code that is compiled into shared objects (.so files). This technique is a **primary architectural feature** of the system and should be preserved throughout development.

## Key Implementation Details

### Embedded Data Arrays

Data is stored in header files that are included directly within C array initializations. This creates a seamless integration between code and data.

```c
/* Header file containing struct array declaration */
struct Customers CustomersData_0[] = {
    /*BEGIN Customers DATA*/
    #include "../data/addressBookData.0.dat.h"  /* Include data directly in array! */
    /*END Customers DATA*/
    NULL /* NULL terminator for easy traversal */
};
```

The included .dat.h file contains pure data entries formatted as C struct initializers:

```c
/*This file autogenerated, do not edit*/
{"0","John Q Public0","Chenoa", readOnly ,{0.1,0,0,0,0}},
{"1","John Q Public1","Chenoa", readOnly ,{0.1,0,0,0,0}},
{"2","John Q Public2","Chenoa", readOnly ,{0.1,0,0,0,0}},
/* ... more data entries ... */
```

### Paged Data Structure

Data is divided into pages with predictable naming patterns:
- `addressBookData.0.dat.h`
- `addressBookData.1.dat.h`
- `addressBookData.2.dat.h`
- etc.

Each page is compiled into a separate shared object (.so) file which can be loaded independently:
- `addressBookData.0.so`
- `addressBookData.1.so`
- etc.

This enables dynamic loading of only the required data pages, reducing memory footprint.

### Accessor Functions

Each compiled data page exports standard accessor functions:

```c
int count(void); /* Returns the number of records in the page */
struct Customers *read(int pos); /* Returns a pointer to a specific record */
```

These functions are dynamically loaded with the data, enabling a consistent interface across all pages.

## Advantages of This Approach

### 1. Zero-Copy Access

Data is directly accessible in memory without parsing or deserialization:

```c
// Access data directly through pointers - no copying required
struct Customers *record = page.read(position);
printf("Name: %s\n", record->name);
```

### 2. Compiler Optimization

The C compiler optimizes data layout and access patterns:
- Memory alignment optimizations
- Potential for compile-time validation of data
- Efficient memory layout based on compiler knowledge

### 3. Type Safety

Data inherits C's type system, ensuring consistency:
- Type errors caught at compile time
- No runtime parsing errors
- Consistent memory representation

### 4. Dynamic Loading

Only needed data pages are loaded into memory:
```c
struct addressBookDynamicPage page = loadPage(pageNumber);
if(page.error == 0) {
    // Use the page data
    int recordCount = page.count();
    // ...
    unload_page(page); // Release when done
}
```

### 5. Zero Serialization/Deserialization Overhead

No conversion between external and internal formats:
- No parsing time
- No formatting time
- No memory overhead for conversion

## Implementation Requirements

All Umbra components must adhere to these principles:

1. **Data as Code**: Data must be embedded in C code, not stored in separate binary formats

2. **Paged Architecture**: Tables must be split into compilable pages of configurable size

3. **Standard Interface**: Each data page must implement consistent accessor functions

4. **NULL Termination**: Arrays should use NULL termination for easier traversal without explicit counts

5. **Automatic Generation**: Tools must generate data header files from SQL operations

6. **Compilation Pipeline**: Changes must flow through the compilation process for data pages

## Generation Workflow

All CRUD operations will follow this workflow:

1. SQL statement is processed (e.g., `INSERT INTO Customers VALUES (...)`)

2. The appropriate data .dat.h file is modified
   - For INSERT: New entries appended to the most recent page
   - For UPDATE: Existing entries modified in place
   - For DELETE: Entries marked with deletion flag

3. When the page reaches maximum size or on COMMIT:
   - Recompile affected .so files
   - Git commit the .dat.h files (not binaries)

4. Queries dynamically load required pages and apply compiled query kernels

## Example Usage

```c
// Load a specific page
struct addressBookDynamicPage page = loadPage(0);

// Access records
int records = page.count();
struct Customers *rec;
int pos = 0;

// Iterate through records
while((rec = page.read(pos)) != NULL) {
    printf("%d.Name = %s\n", pos, rec->name);
    pos++;
}

// Free resources
unload_page(page);
```

## Design Implications

This approach influences the entire system design:

1. **Schema Definition**: Must generate C struct definitions

2. **Query Processing**: Must compile query logic into C filter functions

3. **Modification Operations**: Must update .dat.h files and trigger recompilation

4. **Transactions**: Must track modifications to pages and manage recompilation

5. **Distributed Operation**: Git becomes the natural distribution mechanism

## Conclusion

The direct embedding of data in C code and compilation to shared objects is a fundamental architectural choice for Umbra. This approach offers significant performance advantages through zero-copy access, compiler optimization, and elimination of parsing overhead. All development must preserve and extend this technique as the core data storage and access mechanism.
